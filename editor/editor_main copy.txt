# Originator
class Document:
    # I'm not sure if it's good practice to include
    # constants within a class
    FONTS = ["Arial", "Georgia", "Calibri"]

    # I will initialize it with default values
    def __init__(self):
        self._content = ""
        self._fontName = "Arial"
        self._fontSize = 12
        self._history = History()

    def _create_state(self):
        return DocumentState(self._content, self._fontName, self._fontSize)

    # I need to make this extensible
    def _set_content_from_history(self, state):
        self._content = state._content
        self._fontName = state._fontName
        self._fontSize = state._fontSize

    def _save_history_before_change(self):
        self._history.push(self._create_state())

    # Now we can do the public methods

    def insert(self, text):
        self._save_history_before_change()
        self._content += text

    def delete_last(self, n):
        if n <= 0:
            raise ValueError("n must be positive")
        self._save_history_before_change()
        self._content = self._content[:-n] if n <= len(self._content) else ""

    # This method is our primary highlight for this task

    def undo(self):
        prev = self._history.pop()

        # Can comment out after debugging
        # print(f"Prev is {prev}")

        if prev is None:
            return None

        self._set_content_from_history(prev)

    def change_font(self, _fontName):
        self._save_history_before_change()
        self._fontName = _fontName

    def change_font_size(self, _fontSize):
        self._save_history_before_change()
        self._fontSize = _fontSize

    def __str__(self):
        return f"{self._content}, {self._fontName}, {self._fontSize}"


# Caretaker
class History:
    def __init__(self):
        self._states = []

    # This method is public because another class (Document)
    # needs to know it
    def push(self, state):
        self._states.append(state)

    def pop(self):
        if len(self._states) == 0:
            return None
        return self._states.pop()

    def __len__(self):
        return len(self._states)

    # I'm making this to help debug my undo method
    def __repr__(self):
        return self._states


# Memento
class DocumentState:
    def __init__(self, _content, _fontName, _fontSize):
        self._content = _content
        self._fontName = _fontName
        self._fontSize = _fontSize

    # This is also part of my debugging for my undo method
    # If I don't add this, it will show useless memory location of DocumentState objects in the
    # History() class

    def __repr__(self):
        # Adding angle brackets to help parse the states in the History() list
        return f"<{self._content}, {self._fontName}, {self._fontSize}>\n"


def main():
    document = Document()

    document.insert("Hello")
    document.insert(" CSC7302")
    document.insert("!")
    print(document)  # Hello CSC7302!
    # print(document._history._states)

    document.delete_last(1)
    print(document)  # Hello CSC7302
    # print(document._history._states)

    document.change_font("Georgia")
    print(document)
    # print(document._history._states)

    document.change_font_size(20)
    print(document)
    # print(document._history._states)

    # This is where we are testing the undo for font
    document.undo()  # Should be Hello CS7302, Georgia, 12. And it works now!
    # print(document._history._states)
    print(document)

    document.insert("!!!")
    print(document)  # Hello CSC7302!!!

    document.undo()
    print(document)  # Hello CSC7302

    document.change_font_size(30)
    print(document)
    # print(document._history._states)

    document.undo()
    print(document)
    print(document._history._states)

    document.change_font("Calibri")
    print(document)

    document.undo()
    print(document)

    document.undo()
    print(document)


main()
